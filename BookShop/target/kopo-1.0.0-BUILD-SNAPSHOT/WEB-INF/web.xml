<?xml version="1.0" encoding="UTF-8"?>
<web-app version="2.5" xmlns="http://java.sun.com/xml/ns/javaee"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://java.sun.com/xml/ns/javaee https://java.sun.com/xml/ns/javaee/web-app_2_5.xsd">

	<!-- The definition of the Root Spring Container shared by all Servlets and Filters -->
	<!-- 
		egov의 경우에는 여러 context 파일들이 있는데 전부 불러서 사용하도록 설정되어 있어서 일반적인 spring개발 환경과는 차이가 남.
		빈을 어디에 등록할 것인가?
		
		spring에서는 root-context와 servlet-context 두개만 사용한다.
		이 두 개가 사실 큰 차이가 없음.
		
		멀티 테스킹
			실질적으로 한번에 여러 작업을 할 수는 없다.
			cpu가 하나이기 때문에 빠르게 여러 작업을 왔다갔다함.
			현재 어디를 바라보고 있는야? 무엇이 실행되고 있느냐?
			
			Context-Switching
			
		처음에는 servlet이 여러개 있었지만 지금은 listener하나에 servlet이 배치되어 있음.
			WAC
			Servlet-Context
				
	-->
	<context-param>
		<param-name>contextConfigLocation</param-name>
		<param-value>/WEB-INF/spring/root-context.xml</param-value>
	</context-param>	<!-- rootContext를 읽어옴. -->
	
	<!-- Creates the Spring Container shared by all Servlets and Filters -->
	<!-- 
		가장 먼저 읽히는 것
		리스너 클래스는 지정되어있음.
		이 리스너에게 위에 설정해놓은 root-context.xml을 보내주고 이를 읽어서 처리함.
		context: 문맥
		web context: 웹 어플리케이션 전체에 영향을 주는 context
	 -->
	<listener>
		<listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>
	</listener>

	<!-- Processes application requests -->
	<!--
		spring으로 넘어오면서 어플리테이션 하나에 하나의 서블릿만 존재함.
		egov의 경우에는 모든 xml 파일들을 불러와서 적용되도록 설정되어있음.
		
	-->
	<servlet>
		<servlet-name>appServlet</servlet-name>
		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
		<init-param>
			<param-name>contextConfigLocation</param-name>
			<param-value>/WEB-INF/spring/appServlet/servlet-context.xml</param-value>
		</init-param>
		<load-on-startup>1</load-on-startup>
	</servlet>
	<!--
		스프링의 실체
		스프링에서는 모든 요청을 처리하도록 설정되어있음.
		
		egov의 경우에는 .do로 되어있음.
			web server를 두고 처리함.
			과거에는 was가 static 컨텐츠를 처리하는 능력이 현저하게 떨어졌으나 지금은 그렇지 않기에 굳이 분리해서 작업할 필요가 없음.
			
			문제점?
				1차적인 문제:
					모든 주소에 다 .do를 써야함.
				2차적인 문제:
					개발자가 static 컨텐츠를 통제할 수가 없음.
	-->
	<servlet-mapping>
		<servlet-name>appServlet</servlet-name>
		<url-pattern>/</url-pattern>
	</servlet-mapping>
	<!-- 
		스프링은 모든 요청을 DispatcherServlet에게 보낸다.
			static content도 DispatcherServlet에서 처리하게된다.
			
		egov는 .do로 끝나는 요청만 받는다.
			그 외의 것들은 tomcat이 처리한다.
				static content들은 tomcat이 처리하게됨.
			welcome파일이 처리하게 된다.
	 -->

	<!-- UTF-8 설정 -->
	<filter>
		<filter-name>encodingFilter</filter-name>
		<filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
		<!--
			encoding을 받아서 강제로 세팅해주는 것.
			원래는 개발자가 개발한 코드에서 인코딩을 다 해줬어야했으나 현재는 서블릿보다 앞에 필러로 만들어둬서
			utf8설정을 해줌으로 이후에 인코딩을 따로 해줄 필요가 없어짐.
			
			1. 귀찮음 해결
			2. 파라미터가 처리된 객체로 넘겨 받기 때문에 필수적으로 인코딩을 필터에 잡아줌.
			
		 -->
		 <!-- 
		 	예전에는 annotation을 사용하지 않고 bean등록 하듯이 xml로 만들어서 reference를 잡아서 연결했었음.
		 		1. spring이 처음 나왔을 때는 xml로 다 처리했었는데 프로젝트의 규모가 커졌을 때 유지보수 성이 떨어짐.
		 		
		 		2. annotation + xml으로 작성됨.
		 			관리하기가 용이함.
		 		
		 		3. JavaConfig
		 			xml을 전부 없애고 자바 코드로만 작성하도록 하는 것임.
		 			
		 		4. SpringBoot
		 			-3.0버전부터 쓸만해짐.
		 			-현재도 안정적인 기술은 아님.
		 				작업해놓은 프로젝트가 시간이 지났을 경우 부트 버전이 올라가있으면 버전을 올릴라고 경고 표시뜸.
		 			-java config라는 중간 단계를 거쳐서 자바 코드로만 개발을 하기위해서 만들어진 것이다.
		  -->
		<init-param>
			<param-name>encoding</param-name>
			<param-value>UTF-8</param-value>
		</init-param>
		<init-param>
			<param-name>forceEncoding</param-name>
			<param-value>true</param-value>
		</init-param>
	</filter>

	<filter-mapping>
		<filter-name>encodingFilter</filter-name>
		<url-pattern>/*</url-pattern>
	</filter-mapping>
	<!-- UTF-8 설정 -->
	
</web-app>